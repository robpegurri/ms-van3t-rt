// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: carla.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_carla_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_carla_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_carla_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_carla_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_carla_2eproto;
namespace carla {
class ActorIds;
struct ActorIdsDefaultTypeInternal;
extern ActorIdsDefaultTypeInternal _ActorIds_default_instance_;
class Boolean;
struct BooleanDefaultTypeInternal;
extern BooleanDefaultTypeInternal _Boolean_default_instance_;
class Control;
struct ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class Number;
struct NumberDefaultTypeInternal;
extern NumberDefaultTypeInternal _Number_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class ObjectIn;
struct ObjectInDefaultTypeInternal;
extern ObjectInDefaultTypeInternal _ObjectIn_default_instance_;
class Objects;
struct ObjectsDefaultTypeInternal;
extern ObjectsDefaultTypeInternal _Objects_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace carla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace carla {

// ===================================================================


// -------------------------------------------------------------------

class Vector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(::google::protobuf::internal::ConstantInitialized);

  inline Vector(const Vector& from)
      : Vector(nullptr, from) {}
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector& from) {
    Vector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Vector";
  }
  protected:
  explicit Vector(::google::protobuf::Arena* arena);
  Vector(::google::protobuf::Arena* arena, const Vector& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Vector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Rotation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(::google::protobuf::internal::ConstantInitialized);

  inline Rotation(const Rotation& from)
      : Rotation(nullptr, from) {}
  Rotation(Rotation&& from) noexcept
    : Rotation() {
    *this = ::std::move(from);
  }

  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
               &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Rotation& a, Rotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Rotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rotation& from) {
    Rotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rotation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Rotation";
  }
  protected:
  explicit Rotation(::google::protobuf::Arena* arena);
  Rotation(::google::protobuf::Arena* arena, const Rotation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kYawFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // double pitch = 1;
  void clear_pitch() ;
  double pitch() const;
  void set_pitch(double value);

  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);

  public:
  // double yaw = 2;
  void clear_yaw() ;
  double yaw() const;
  void set_yaw(double value);

  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);

  public:
  // double roll = 3;
  void clear_roll() ;
  double roll() const;
  void set_roll(double value);

  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Rotation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double pitch_;
    double yaw_;
    double roll_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Number final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Number) */ {
 public:
  inline Number() : Number(nullptr) {}
  ~Number() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Number(::google::protobuf::internal::ConstantInitialized);

  inline Number(const Number& from)
      : Number(nullptr, from) {}
  Number(Number&& from) noexcept
    : Number() {
    *this = ::std::move(from);
  }

  inline Number& operator=(const Number& from) {
    CopyFrom(from);
    return *this;
  }
  inline Number& operator=(Number&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Number& default_instance() {
    return *internal_default_instance();
  }
  static inline const Number* internal_default_instance() {
    return reinterpret_cast<const Number*>(
               &_Number_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Number& a, Number& b) {
    a.Swap(&b);
  }
  inline void Swap(Number* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Number* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Number* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Number>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Number& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Number& from) {
    Number::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Number* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Number";
  }
  protected:
  explicit Number(::google::protobuf::Arena* arena);
  Number(::google::protobuf::Arena* arena, const Number& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 1,
  };
  // int32 num = 1;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Number)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t num_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Boolean final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Boolean) */ {
 public:
  inline Boolean() : Boolean(nullptr) {}
  ~Boolean() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Boolean(::google::protobuf::internal::ConstantInitialized);

  inline Boolean(const Boolean& from)
      : Boolean(nullptr, from) {}
  Boolean(Boolean&& from) noexcept
    : Boolean() {
    *this = ::std::move(from);
  }

  inline Boolean& operator=(const Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  inline Boolean& operator=(Boolean&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Boolean& default_instance() {
    return *internal_default_instance();
  }
  static inline const Boolean* internal_default_instance() {
    return reinterpret_cast<const Boolean*>(
               &_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Boolean& a, Boolean& b) {
    a.Swap(&b);
  }
  inline void Swap(Boolean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Boolean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Boolean* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Boolean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Boolean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Boolean& from) {
    Boolean::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Boolean* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Boolean";
  }
  protected:
  explicit Boolean(::google::protobuf::Arena* arena);
  Boolean(::google::protobuf::Arena* arena, const Boolean& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Boolean)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class ActorIds final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.ActorIds) */ {
 public:
  inline ActorIds() : ActorIds(nullptr) {}
  ~ActorIds() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ActorIds(::google::protobuf::internal::ConstantInitialized);

  inline ActorIds(const ActorIds& from)
      : ActorIds(nullptr, from) {}
  ActorIds(ActorIds&& from) noexcept
    : ActorIds() {
    *this = ::std::move(from);
  }

  inline ActorIds& operator=(const ActorIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorIds& operator=(ActorIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorIds* internal_default_instance() {
    return reinterpret_cast<const ActorIds*>(
               &_ActorIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ActorIds& a, ActorIds& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorIds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorIds* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActorIds* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActorIds>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActorIds& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ActorIds& from) {
    ActorIds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActorIds* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.ActorIds";
  }
  protected:
  explicit ActorIds(::google::protobuf::Arena* arena);
  ActorIds(::google::protobuf::Arena* arena, const ActorIds& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
  };
  // repeated int32 actorId = 1;
  int actorid_size() const;
  private:
  int _internal_actorid_size() const;

  public:
  void clear_actorid() ;
  ::int32_t actorid(int index) const;
  void set_actorid(int index, ::int32_t value);
  void add_actorid(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& actorid() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_actorid();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_actorid() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_actorid();

  public:
  // @@protoc_insertion_point(class_scope:carla.ActorIds)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> actorid_;
    mutable ::google::protobuf::internal::CachedSize _actorid_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Transform final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transform(::google::protobuf::internal::ConstantInitialized);

  inline Transform(const Transform& from)
      : Transform(nullptr, from) {}
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transform* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Transform& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Transform& from) {
    Transform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transform* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Transform";
  }
  protected:
  explicit Transform(::google::protobuf::Arena* arena);
  Transform(::google::protobuf::Arena* arena, const Transform& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .carla.Vector location = 1;
  bool has_location() const;
  void clear_location() ;
  const ::carla::Vector& location() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_location();
  ::carla::Vector* mutable_location();
  void set_allocated_location(::carla::Vector* value);
  void unsafe_arena_set_allocated_location(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_location();

  private:
  const ::carla::Vector& _internal_location() const;
  ::carla::Vector* _internal_mutable_location();

  public:
  // .carla.Rotation rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::carla::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::carla::Rotation* release_rotation();
  ::carla::Rotation* mutable_rotation();
  void set_allocated_rotation(::carla::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::carla::Rotation* value);
  ::carla::Rotation* unsafe_arena_release_rotation();

  private:
  const ::carla::Rotation& _internal_rotation() const;
  ::carla::Rotation* _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:carla.Transform)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::carla::Vector* location_;
    ::carla::Rotation* rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Control final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Control) */ {
 public:
  inline Control() : Control(nullptr) {}
  ~Control() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Control(::google::protobuf::internal::ConstantInitialized);

  inline Control(const Control& from)
      : Control(nullptr, from) {}
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Control* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Control& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Control& from) {
    Control::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Control* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Control";
  }
  protected:
  explicit Control(::google::protobuf::Arena* arena);
  Control(::google::protobuf::Arena* arena, const Control& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // .carla.Vector waypoint = 2;
  bool has_waypoint() const;
  void clear_waypoint() ;
  const ::carla::Vector& waypoint() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_waypoint();
  ::carla::Vector* mutable_waypoint();
  void set_allocated_waypoint(::carla::Vector* value);
  void unsafe_arena_set_allocated_waypoint(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_waypoint();

  private:
  const ::carla::Vector& _internal_waypoint() const;
  ::carla::Vector* _internal_mutable_waypoint();

  public:
  // double speed = 3;
  void clear_speed() ;
  double speed() const;
  void set_speed(double value);

  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);

  public:
  // double acceleration = 4;
  void clear_acceleration() ;
  double acceleration() const;
  void set_acceleration(double value);

  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Control)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::carla::Vector* waypoint_;
    double speed_;
    double acceleration_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Vehicle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vehicle(::google::protobuf::internal::ConstantInitialized);

  inline Vehicle(const Vehicle& from)
      : Vehicle(nullptr, from) {}
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vehicle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Vehicle";
  }
  protected:
  explicit Vehicle(::google::protobuf::Arena* arena);
  Vehicle(::google::protobuf::Arena* arena, const Vehicle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kLocationFieldNumber = 4,
    kTransformFieldNumber = 11,
    kLatitudeFieldNumber = 5,
    kIdFieldNumber = 1,
    kLaneFieldNumber = 9,
    kLongitudeFieldNumber = 6,
    kLengthFieldNumber = 7,
    kWidthFieldNumber = 8,
    kHeadingFieldNumber = 10,
  };
  // .carla.Vector speed = 2;
  bool has_speed() const;
  void clear_speed() ;
  const ::carla::Vector& speed() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_speed();
  ::carla::Vector* mutable_speed();
  void set_allocated_speed(::carla::Vector* value);
  void unsafe_arena_set_allocated_speed(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_speed();

  private:
  const ::carla::Vector& _internal_speed() const;
  ::carla::Vector* _internal_mutable_speed();

  public:
  // .carla.Vector acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::carla::Vector& acceleration() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_acceleration();
  ::carla::Vector* mutable_acceleration();
  void set_allocated_acceleration(::carla::Vector* value);
  void unsafe_arena_set_allocated_acceleration(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_acceleration();

  private:
  const ::carla::Vector& _internal_acceleration() const;
  ::carla::Vector* _internal_mutable_acceleration();

  public:
  // .carla.Vector location = 4;
  bool has_location() const;
  void clear_location() ;
  const ::carla::Vector& location() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_location();
  ::carla::Vector* mutable_location();
  void set_allocated_location(::carla::Vector* value);
  void unsafe_arena_set_allocated_location(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_location();

  private:
  const ::carla::Vector& _internal_location() const;
  ::carla::Vector* _internal_mutable_location();

  public:
  // .carla.Transform transform = 11;
  bool has_transform() const;
  void clear_transform() ;
  const ::carla::Transform& transform() const;
  PROTOBUF_NODISCARD ::carla::Transform* release_transform();
  ::carla::Transform* mutable_transform();
  void set_allocated_transform(::carla::Transform* value);
  void unsafe_arena_set_allocated_transform(::carla::Transform* value);
  ::carla::Transform* unsafe_arena_release_transform();

  private:
  const ::carla::Transform& _internal_transform() const;
  ::carla::Transform* _internal_mutable_transform();

  public:
  // double latitude = 5;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 lane = 9;
  void clear_lane() ;
  ::int32_t lane() const;
  void set_lane(::int32_t value);

  private:
  ::int32_t _internal_lane() const;
  void _internal_set_lane(::int32_t value);

  public:
  // double longitude = 6;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // double length = 7;
  void clear_length() ;
  double length() const;
  void set_length(double value);

  private:
  double _internal_length() const;
  void _internal_set_length(double value);

  public:
  // double width = 8;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // double heading = 10;
  void clear_heading() ;
  double heading() const;
  void set_heading(double value);

  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Vehicle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::carla::Vector* speed_;
    ::carla::Vector* acceleration_;
    ::carla::Vector* location_;
    ::carla::Transform* transform_;
    double latitude_;
    ::int32_t id_;
    ::int32_t lane_;
    double longitude_;
    double length_;
    double width_;
    double heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Object final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Object(::google::protobuf::internal::ConstantInitialized);

  inline Object(const Object& from)
      : Object(nullptr, from) {}
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Object* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Object";
  }
  protected:
  explicit Object(::google::protobuf::Arena* arena);
  Object(::google::protobuf::Arena* arena, const Object& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 4,
    kAccelerationFieldNumber = 5,
    kTransformFieldNumber = 13,
    kDxFieldNumber = 2,
    kDyFieldNumber = 3,
    kIdFieldNumber = 1,
    kTimestampFieldNumber = 10,
    kLengthFieldNumber = 6,
    kWidthFieldNumber = 7,
    kConfidenceFieldNumber = 11,
    kOnSightFieldNumber = 8,
    kTrackedFieldNumber = 9,
    kDetectedFieldNumber = 14,
    kPerceivedByFieldNumber = 15,
    kYawFieldNumber = 12,
  };
  // .carla.Vector speed = 4;
  bool has_speed() const;
  void clear_speed() ;
  const ::carla::Vector& speed() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_speed();
  ::carla::Vector* mutable_speed();
  void set_allocated_speed(::carla::Vector* value);
  void unsafe_arena_set_allocated_speed(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_speed();

  private:
  const ::carla::Vector& _internal_speed() const;
  ::carla::Vector* _internal_mutable_speed();

  public:
  // .carla.Vector acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::carla::Vector& acceleration() const;
  PROTOBUF_NODISCARD ::carla::Vector* release_acceleration();
  ::carla::Vector* mutable_acceleration();
  void set_allocated_acceleration(::carla::Vector* value);
  void unsafe_arena_set_allocated_acceleration(::carla::Vector* value);
  ::carla::Vector* unsafe_arena_release_acceleration();

  private:
  const ::carla::Vector& _internal_acceleration() const;
  ::carla::Vector* _internal_mutable_acceleration();

  public:
  // .carla.Transform transform = 13;
  bool has_transform() const;
  void clear_transform() ;
  const ::carla::Transform& transform() const;
  PROTOBUF_NODISCARD ::carla::Transform* release_transform();
  ::carla::Transform* mutable_transform();
  void set_allocated_transform(::carla::Transform* value);
  void unsafe_arena_set_allocated_transform(::carla::Transform* value);
  ::carla::Transform* unsafe_arena_release_transform();

  private:
  const ::carla::Transform& _internal_transform() const;
  ::carla::Transform* _internal_mutable_transform();

  public:
  // double dx = 2;
  void clear_dx() ;
  double dx() const;
  void set_dx(double value);

  private:
  double _internal_dx() const;
  void _internal_set_dx(double value);

  public:
  // double dy = 3;
  void clear_dy() ;
  double dy() const;
  void set_dy(double value);

  private:
  double _internal_dy() const;
  void _internal_set_dy(double value);

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 timestamp = 10;
  void clear_timestamp() ;
  ::int32_t timestamp() const;
  void set_timestamp(::int32_t value);

  private:
  ::int32_t _internal_timestamp() const;
  void _internal_set_timestamp(::int32_t value);

  public:
  // double length = 6;
  void clear_length() ;
  double length() const;
  void set_length(double value);

  private:
  double _internal_length() const;
  void _internal_set_length(double value);

  public:
  // double width = 7;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // double confidence = 11;
  void clear_confidence() ;
  double confidence() const;
  void set_confidence(double value);

  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);

  public:
  // bool onSight = 8;
  void clear_onsight() ;
  bool onsight() const;
  void set_onsight(bool value);

  private:
  bool _internal_onsight() const;
  void _internal_set_onsight(bool value);

  public:
  // bool tracked = 9;
  void clear_tracked() ;
  bool tracked() const;
  void set_tracked(bool value);

  private:
  bool _internal_tracked() const;
  void _internal_set_tracked(bool value);

  public:
  // bool detected = 14;
  void clear_detected() ;
  bool detected() const;
  void set_detected(bool value);

  private:
  bool _internal_detected() const;
  void _internal_set_detected(bool value);

  public:
  // int32 perceivedBy = 15;
  void clear_perceivedby() ;
  ::int32_t perceivedby() const;
  void set_perceivedby(::int32_t value);

  private:
  ::int32_t _internal_perceivedby() const;
  void _internal_set_perceivedby(::int32_t value);

  public:
  // double yaw = 12;
  void clear_yaw() ;
  double yaw() const;
  void set_yaw(double value);

  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);

  public:
  // @@protoc_insertion_point(class_scope:carla.Object)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::carla::Vector* speed_;
    ::carla::Vector* acceleration_;
    ::carla::Transform* transform_;
    double dx_;
    double dy_;
    ::int32_t id_;
    ::int32_t timestamp_;
    double length_;
    double width_;
    double confidence_;
    bool onsight_;
    bool tracked_;
    bool detected_;
    ::int32_t perceivedby_;
    double yaw_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class Objects final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.Objects) */ {
 public:
  inline Objects() : Objects(nullptr) {}
  ~Objects() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Objects(::google::protobuf::internal::ConstantInitialized);

  inline Objects(const Objects& from)
      : Objects(nullptr, from) {}
  Objects(Objects&& from) noexcept
    : Objects() {
    *this = ::std::move(from);
  }

  inline Objects& operator=(const Objects& from) {
    CopyFrom(from);
    return *this;
  }
  inline Objects& operator=(Objects&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Objects& default_instance() {
    return *internal_default_instance();
  }
  static inline const Objects* internal_default_instance() {
    return reinterpret_cast<const Objects*>(
               &_Objects_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Objects& a, Objects& b) {
    a.Swap(&b);
  }
  inline void Swap(Objects* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Objects* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Objects* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Objects>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Objects& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Objects& from) {
    Objects::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Objects* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.Objects";
  }
  protected:
  explicit Objects(::google::protobuf::Arena* arena);
  Objects(::google::protobuf::Arena* arena, const Objects& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .carla.Object objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  ::carla::Object* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::carla::Object >*
      mutable_objects();
  private:
  const ::google::protobuf::RepeatedPtrField<::carla::Object>& _internal_objects() const;
  ::google::protobuf::RepeatedPtrField<::carla::Object>* _internal_mutable_objects();
  public:
  const ::carla::Object& objects(int index) const;
  ::carla::Object* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::carla::Object >&
      objects() const;
  // @@protoc_insertion_point(class_scope:carla.Objects)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::carla::Object > objects_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};// -------------------------------------------------------------------

class ObjectIn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla.ObjectIn) */ {
 public:
  inline ObjectIn() : ObjectIn(nullptr) {}
  ~ObjectIn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectIn(::google::protobuf::internal::ConstantInitialized);

  inline ObjectIn(const ObjectIn& from)
      : ObjectIn(nullptr, from) {}
  ObjectIn(ObjectIn&& from) noexcept
    : ObjectIn() {
    *this = ::std::move(from);
  }

  inline ObjectIn& operator=(const ObjectIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectIn& operator=(ObjectIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectIn* internal_default_instance() {
    return reinterpret_cast<const ObjectIn*>(
               &_ObjectIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObjectIn& a, ObjectIn& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectIn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectIn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectIn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectIn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ObjectIn& from) {
    ObjectIn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectIn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "carla.ObjectIn";
  }
  protected:
  explicit ObjectIn(::google::protobuf::Arena* arena);
  ObjectIn(::google::protobuf::Arena* arena, const ObjectIn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kEgoIdFieldNumber = 2,
    kFromIdFieldNumber = 3,
  };
  // .carla.Object object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::carla::Object& object() const;
  PROTOBUF_NODISCARD ::carla::Object* release_object();
  ::carla::Object* mutable_object();
  void set_allocated_object(::carla::Object* value);
  void unsafe_arena_set_allocated_object(::carla::Object* value);
  ::carla::Object* unsafe_arena_release_object();

  private:
  const ::carla::Object& _internal_object() const;
  ::carla::Object* _internal_mutable_object();

  public:
  // int32 egoId = 2;
  void clear_egoid() ;
  ::int32_t egoid() const;
  void set_egoid(::int32_t value);

  private:
  ::int32_t _internal_egoid() const;
  void _internal_set_egoid(::int32_t value);

  public:
  // int32 fromId = 3;
  void clear_fromid() ;
  ::int32_t fromid() const;
  void set_fromid(::int32_t value);

  private:
  ::int32_t _internal_fromid() const;
  void _internal_set_fromid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:carla.ObjectIn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::carla::Object* object_;
    ::int32_t egoid_;
    ::int32_t fromid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_carla_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ActorIds

// repeated int32 actorId = 1;
inline int ActorIds::_internal_actorid_size() const {
  return _internal_actorid().size();
}
inline int ActorIds::actorid_size() const {
  return _internal_actorid_size();
}
inline void ActorIds::clear_actorid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actorid_.Clear();
}
inline ::int32_t ActorIds::actorid(int index) const {
  // @@protoc_insertion_point(field_get:carla.ActorIds.actorId)
  return _internal_actorid().Get(index);
}
inline void ActorIds::set_actorid(int index, ::int32_t value) {
  _internal_mutable_actorid()->Set(index, value);
  // @@protoc_insertion_point(field_set:carla.ActorIds.actorId)
}
inline void ActorIds::add_actorid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actorid()->Add(value);
  // @@protoc_insertion_point(field_add:carla.ActorIds.actorId)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ActorIds::actorid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:carla.ActorIds.actorId)
  return _internal_actorid();
}
inline ::google::protobuf::RepeatedField<::int32_t>* ActorIds::mutable_actorid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:carla.ActorIds.actorId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actorid();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ActorIds::_internal_actorid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actorid_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* ActorIds::_internal_mutable_actorid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actorid_;
}

// -------------------------------------------------------------------

// Number

// int32 num = 1;
inline void Number::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
}
inline ::int32_t Number::num() const {
  // @@protoc_insertion_point(field_get:carla.Number.num)
  return _internal_num();
}
inline void Number::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:carla.Number.num)
}
inline ::int32_t Number::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void Number::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_ = value;
}

// -------------------------------------------------------------------

// Vehicle

// int32 id = 1;
inline void Vehicle::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Vehicle::id() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.id)
  return _internal_id();
}
inline void Vehicle::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.id)
}
inline ::int32_t Vehicle::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Vehicle::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .carla.Vector speed = 2;
inline bool Vehicle::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_ != nullptr);
  return value;
}
inline void Vehicle::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.speed_ != nullptr) _impl_.speed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::carla::Vector& Vehicle::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Vehicle::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Vehicle.speed)
  return _internal_speed();
}
inline void Vehicle::unsafe_arena_set_allocated_speed(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }
  _impl_.speed_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Vehicle.speed)
}
inline ::carla::Vector* Vehicle::release_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* released = _impl_.speed_;
  _impl_.speed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Vehicle::unsafe_arena_release_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Vehicle.speed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* temp = _impl_.speed_;
  _impl_.speed_ = nullptr;
  return temp;
}
inline ::carla::Vector* Vehicle::_internal_mutable_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.speed_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.speed_;
}
inline ::carla::Vector* Vehicle::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:carla.Vehicle.speed)
  return _msg;
}
inline void Vehicle::set_allocated_speed(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.speed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.speed_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Vehicle.speed)
}

// .carla.Vector acceleration = 3;
inline bool Vehicle::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline void Vehicle::clear_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.acceleration_ != nullptr) _impl_.acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::carla::Vector& Vehicle::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Vehicle::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Vehicle.acceleration)
  return _internal_acceleration();
}
inline void Vehicle::unsafe_arena_set_allocated_acceleration(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Vehicle.acceleration)
}
inline ::carla::Vector* Vehicle::release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Vector* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Vehicle::unsafe_arena_release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Vehicle.acceleration)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Vector* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::carla::Vector* Vehicle::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.acceleration_;
}
inline ::carla::Vector* Vehicle::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:carla.Vehicle.acceleration)
  return _msg;
}
inline void Vehicle::set_allocated_acceleration(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Vehicle.acceleration)
}

// .carla.Vector location = 4;
inline bool Vehicle::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Vehicle::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::carla::Vector& Vehicle::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Vehicle::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Vehicle.location)
  return _internal_location();
}
inline void Vehicle::unsafe_arena_set_allocated_location(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Vehicle.location)
}
inline ::carla::Vector* Vehicle::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::carla::Vector* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Vehicle::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Vehicle.location)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::carla::Vector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::carla::Vector* Vehicle::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.location_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.location_;
}
inline ::carla::Vector* Vehicle::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:carla.Vehicle.location)
  return _msg;
}
inline void Vehicle::set_allocated_location(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.location_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Vehicle.location)
}

// double latitude = 5;
inline void Vehicle::clear_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latitude_ = 0;
}
inline double Vehicle::latitude() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.latitude)
  return _internal_latitude();
}
inline void Vehicle::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.latitude)
}
inline double Vehicle::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void Vehicle::_internal_set_latitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.latitude_ = value;
}

// double longitude = 6;
inline void Vehicle::clear_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.longitude_ = 0;
}
inline double Vehicle::longitude() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.longitude)
  return _internal_longitude();
}
inline void Vehicle::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.longitude)
}
inline double Vehicle::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void Vehicle::_internal_set_longitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.longitude_ = value;
}

// double length = 7;
inline void Vehicle::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_ = 0;
}
inline double Vehicle::length() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.length)
  return _internal_length();
}
inline void Vehicle::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.length)
}
inline double Vehicle::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline void Vehicle::_internal_set_length(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_ = value;
}

// double width = 8;
inline void Vehicle::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline double Vehicle::width() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.width)
  return _internal_width();
}
inline void Vehicle::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.width)
}
inline double Vehicle::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Vehicle::_internal_set_width(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// int32 lane = 9;
inline void Vehicle::clear_lane() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_ = 0;
}
inline ::int32_t Vehicle::lane() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.lane)
  return _internal_lane();
}
inline void Vehicle::set_lane(::int32_t value) {
  _internal_set_lane(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.lane)
}
inline ::int32_t Vehicle::_internal_lane() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_;
}
inline void Vehicle::_internal_set_lane(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lane_ = value;
}

// double heading = 10;
inline void Vehicle::clear_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heading_ = 0;
}
inline double Vehicle::heading() const {
  // @@protoc_insertion_point(field_get:carla.Vehicle.heading)
  return _internal_heading();
}
inline void Vehicle::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:carla.Vehicle.heading)
}
inline double Vehicle::_internal_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heading_;
}
inline void Vehicle::_internal_set_heading(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heading_ = value;
}

// .carla.Transform transform = 11;
inline bool Vehicle::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void Vehicle::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::carla::Transform& Vehicle::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Transform&>(::carla::_Transform_default_instance_);
}
inline const ::carla::Transform& Vehicle::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Vehicle.transform)
  return _internal_transform();
}
inline void Vehicle::unsafe_arena_set_allocated_transform(::carla::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::carla::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Vehicle.transform)
}
inline ::carla::Transform* Vehicle::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::carla::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Transform* Vehicle::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Vehicle.transform)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::carla::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::carla::Transform* Vehicle::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::carla::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::carla::Transform* Vehicle::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:carla.Vehicle.transform)
  return _msg;
}
inline void Vehicle::set_allocated_transform(::carla::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.transform_ = reinterpret_cast<::carla::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Vehicle.transform)
}

// -------------------------------------------------------------------

// Vector

// double x = 1;
inline void Vector::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Vector::x() const {
  // @@protoc_insertion_point(field_get:carla.Vector.x)
  return _internal_x();
}
inline void Vector::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:carla.Vector.x)
}
inline double Vector::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Vector::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Vector::y() const {
  // @@protoc_insertion_point(field_get:carla.Vector.y)
  return _internal_y();
}
inline void Vector::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:carla.Vector.y)
}
inline double Vector::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Vector::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Vector::z() const {
  // @@protoc_insertion_point(field_get:carla.Vector.z)
  return _internal_z();
}
inline void Vector::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:carla.Vector.z)
}
inline double Vector::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vector::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotation

// double pitch = 1;
inline void Rotation::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pitch_ = 0;
}
inline double Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:carla.Rotation.pitch)
  return _internal_pitch();
}
inline void Rotation::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:carla.Rotation.pitch)
}
inline double Rotation::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pitch_;
}
inline void Rotation::_internal_set_pitch(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pitch_ = value;
}

// double yaw = 2;
inline void Rotation::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.yaw_ = 0;
}
inline double Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:carla.Rotation.yaw)
  return _internal_yaw();
}
inline void Rotation::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:carla.Rotation.yaw)
}
inline double Rotation::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.yaw_;
}
inline void Rotation::_internal_set_yaw(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.yaw_ = value;
}

// double roll = 3;
inline void Rotation::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roll_ = 0;
}
inline double Rotation::roll() const {
  // @@protoc_insertion_point(field_get:carla.Rotation.roll)
  return _internal_roll();
}
inline void Rotation::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:carla.Rotation.roll)
}
inline double Rotation::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roll_;
}
inline void Rotation::_internal_set_roll(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roll_ = value;
}

// -------------------------------------------------------------------

// Transform

// .carla.Vector location = 1;
inline bool Transform::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Transform::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::carla::Vector& Transform::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Transform::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Transform.location)
  return _internal_location();
}
inline void Transform::unsafe_arena_set_allocated_location(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Transform.location)
}
inline ::carla::Vector* Transform::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Transform::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Transform.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::carla::Vector* Transform::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.location_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.location_;
}
inline ::carla::Vector* Transform::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:carla.Transform.location)
  return _msg;
}
inline void Transform::set_allocated_location(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Transform.location)
}

// .carla.Rotation rotation = 2;
inline bool Transform::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Transform::clear_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::carla::Rotation& Transform::_internal_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Rotation&>(::carla::_Rotation_default_instance_);
}
inline const ::carla::Rotation& Transform::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Transform.rotation)
  return _internal_rotation();
}
inline void Transform::unsafe_arena_set_allocated_rotation(::carla::Rotation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::carla::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Transform.rotation)
}
inline ::carla::Rotation* Transform::release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Rotation* Transform::unsafe_arena_release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Transform.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::carla::Rotation* Transform::_internal_mutable_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::carla::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::carla::Rotation* Transform::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:carla.Transform.rotation)
  return _msg;
}
inline void Transform::set_allocated_rotation(::carla::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Rotation*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Rotation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::carla::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Transform.rotation)
}

// -------------------------------------------------------------------

// Object

// int32 id = 1;
inline void Object::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Object::id() const {
  // @@protoc_insertion_point(field_get:carla.Object.id)
  return _internal_id();
}
inline void Object::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:carla.Object.id)
}
inline ::int32_t Object::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Object::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// double dx = 2;
inline void Object::clear_dx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dx_ = 0;
}
inline double Object::dx() const {
  // @@protoc_insertion_point(field_get:carla.Object.dx)
  return _internal_dx();
}
inline void Object::set_dx(double value) {
  _internal_set_dx(value);
  // @@protoc_insertion_point(field_set:carla.Object.dx)
}
inline double Object::_internal_dx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dx_;
}
inline void Object::_internal_set_dx(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dx_ = value;
}

// double dy = 3;
inline void Object::clear_dy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dy_ = 0;
}
inline double Object::dy() const {
  // @@protoc_insertion_point(field_get:carla.Object.dy)
  return _internal_dy();
}
inline void Object::set_dy(double value) {
  _internal_set_dy(value);
  // @@protoc_insertion_point(field_set:carla.Object.dy)
}
inline double Object::_internal_dy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dy_;
}
inline void Object::_internal_set_dy(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dy_ = value;
}

// .carla.Vector speed = 4;
inline bool Object::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_ != nullptr);
  return value;
}
inline void Object::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.speed_ != nullptr) _impl_.speed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::carla::Vector& Object::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Object::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Object.speed)
  return _internal_speed();
}
inline void Object::unsafe_arena_set_allocated_speed(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }
  _impl_.speed_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Object.speed)
}
inline ::carla::Vector* Object::release_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* released = _impl_.speed_;
  _impl_.speed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Object::unsafe_arena_release_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Object.speed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* temp = _impl_.speed_;
  _impl_.speed_ = nullptr;
  return temp;
}
inline ::carla::Vector* Object::_internal_mutable_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.speed_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.speed_;
}
inline ::carla::Vector* Object::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:carla.Object.speed)
  return _msg;
}
inline void Object::set_allocated_speed(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.speed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.speed_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Object.speed)
}

// .carla.Vector acceleration = 5;
inline bool Object::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline void Object::clear_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.acceleration_ != nullptr) _impl_.acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::carla::Vector& Object::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Object::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Object.acceleration)
  return _internal_acceleration();
}
inline void Object::unsafe_arena_set_allocated_acceleration(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Object.acceleration)
}
inline ::carla::Vector* Object::release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Vector* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Object::unsafe_arena_release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Object.acceleration)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::carla::Vector* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::carla::Vector* Object::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.acceleration_;
}
inline ::carla::Vector* Object::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:carla.Object.acceleration)
  return _msg;
}
inline void Object::set_allocated_acceleration(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.acceleration_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Object.acceleration)
}

// double length = 6;
inline void Object::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_ = 0;
}
inline double Object::length() const {
  // @@protoc_insertion_point(field_get:carla.Object.length)
  return _internal_length();
}
inline void Object::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:carla.Object.length)
}
inline double Object::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline void Object::_internal_set_length(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_ = value;
}

// double width = 7;
inline void Object::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline double Object::width() const {
  // @@protoc_insertion_point(field_get:carla.Object.width)
  return _internal_width();
}
inline void Object::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:carla.Object.width)
}
inline double Object::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Object::_internal_set_width(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// bool onSight = 8;
inline void Object::clear_onsight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onsight_ = false;
}
inline bool Object::onsight() const {
  // @@protoc_insertion_point(field_get:carla.Object.onSight)
  return _internal_onsight();
}
inline void Object::set_onsight(bool value) {
  _internal_set_onsight(value);
  // @@protoc_insertion_point(field_set:carla.Object.onSight)
}
inline bool Object::_internal_onsight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onsight_;
}
inline void Object::_internal_set_onsight(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onsight_ = value;
}

// bool tracked = 9;
inline void Object::clear_tracked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tracked_ = false;
}
inline bool Object::tracked() const {
  // @@protoc_insertion_point(field_get:carla.Object.tracked)
  return _internal_tracked();
}
inline void Object::set_tracked(bool value) {
  _internal_set_tracked(value);
  // @@protoc_insertion_point(field_set:carla.Object.tracked)
}
inline bool Object::_internal_tracked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tracked_;
}
inline void Object::_internal_set_tracked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tracked_ = value;
}

// int32 timestamp = 10;
inline void Object::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = 0;
}
inline ::int32_t Object::timestamp() const {
  // @@protoc_insertion_point(field_get:carla.Object.timestamp)
  return _internal_timestamp();
}
inline void Object::set_timestamp(::int32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:carla.Object.timestamp)
}
inline ::int32_t Object::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Object::_internal_set_timestamp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// double confidence = 11;
inline void Object::clear_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = 0;
}
inline double Object::confidence() const {
  // @@protoc_insertion_point(field_get:carla.Object.confidence)
  return _internal_confidence();
}
inline void Object::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:carla.Object.confidence)
}
inline double Object::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_;
}
inline void Object::_internal_set_confidence(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.confidence_ = value;
}

// double yaw = 12;
inline void Object::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.yaw_ = 0;
}
inline double Object::yaw() const {
  // @@protoc_insertion_point(field_get:carla.Object.yaw)
  return _internal_yaw();
}
inline void Object::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:carla.Object.yaw)
}
inline double Object::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.yaw_;
}
inline void Object::_internal_set_yaw(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.yaw_ = value;
}

// .carla.Transform transform = 13;
inline bool Object::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void Object::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::carla::Transform& Object::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Transform&>(::carla::_Transform_default_instance_);
}
inline const ::carla::Transform& Object::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Object.transform)
  return _internal_transform();
}
inline void Object::unsafe_arena_set_allocated_transform(::carla::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::carla::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Object.transform)
}
inline ::carla::Transform* Object::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::carla::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Transform* Object::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Object.transform)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::carla::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::carla::Transform* Object::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::carla::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::carla::Transform* Object::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:carla.Object.transform)
  return _msg;
}
inline void Object::set_allocated_transform(::carla::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transform_ = reinterpret_cast<::carla::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Object.transform)
}

// bool detected = 14;
inline void Object::clear_detected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.detected_ = false;
}
inline bool Object::detected() const {
  // @@protoc_insertion_point(field_get:carla.Object.detected)
  return _internal_detected();
}
inline void Object::set_detected(bool value) {
  _internal_set_detected(value);
  // @@protoc_insertion_point(field_set:carla.Object.detected)
}
inline bool Object::_internal_detected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detected_;
}
inline void Object::_internal_set_detected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.detected_ = value;
}

// int32 perceivedBy = 15;
inline void Object::clear_perceivedby() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perceivedby_ = 0;
}
inline ::int32_t Object::perceivedby() const {
  // @@protoc_insertion_point(field_get:carla.Object.perceivedBy)
  return _internal_perceivedby();
}
inline void Object::set_perceivedby(::int32_t value) {
  _internal_set_perceivedby(value);
  // @@protoc_insertion_point(field_set:carla.Object.perceivedBy)
}
inline ::int32_t Object::_internal_perceivedby() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perceivedby_;
}
inline void Object::_internal_set_perceivedby(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perceivedby_ = value;
}

// -------------------------------------------------------------------

// Objects

// repeated .carla.Object objects = 1;
inline int Objects::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int Objects::objects_size() const {
  return _internal_objects_size();
}
inline void Objects::clear_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objects_.Clear();
}
inline ::carla::Object* Objects::mutable_objects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:carla.Objects.objects)
  return _internal_mutable_objects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::carla::Object>* Objects::mutable_objects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:carla.Objects.objects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objects();
}
inline const ::carla::Object& Objects::objects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Objects.objects)
  return _internal_objects().Get(index);
}
inline ::carla::Object* Objects::add_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::carla::Object* _add = _internal_mutable_objects()->Add();
  // @@protoc_insertion_point(field_add:carla.Objects.objects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::carla::Object>& Objects::objects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:carla.Objects.objects)
  return _internal_objects();
}
inline const ::google::protobuf::RepeatedPtrField<::carla::Object>&
Objects::_internal_objects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objects_;
}
inline ::google::protobuf::RepeatedPtrField<::carla::Object>*
Objects::_internal_mutable_objects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objects_;
}

// -------------------------------------------------------------------

// Boolean

// bool value = 1;
inline void Boolean::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = false;
}
inline bool Boolean::value() const {
  // @@protoc_insertion_point(field_get:carla.Boolean.value)
  return _internal_value();
}
inline void Boolean::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:carla.Boolean.value)
}
inline bool Boolean::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void Boolean::_internal_set_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ObjectIn

// .carla.Object object = 1;
inline bool ObjectIn::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void ObjectIn::clear_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::carla::Object& ObjectIn::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Object&>(::carla::_Object_default_instance_);
}
inline const ::carla::Object& ObjectIn::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.ObjectIn.object)
  return _internal_object();
}
inline void ObjectIn::unsafe_arena_set_allocated_object(::carla::Object* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::carla::Object*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.ObjectIn.object)
}
inline ::carla::Object* ObjectIn::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Object* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Object* ObjectIn::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.ObjectIn.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::carla::Object* ObjectIn::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Object>(GetArena());
    _impl_.object_ = reinterpret_cast<::carla::Object*>(p);
  }
  return _impl_.object_;
}
inline ::carla::Object* ObjectIn::mutable_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:carla.ObjectIn.object)
  return _msg;
}
inline void ObjectIn::set_allocated_object(::carla::Object* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Object*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Object*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::carla::Object*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.ObjectIn.object)
}

// int32 egoId = 2;
inline void ObjectIn::clear_egoid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egoid_ = 0;
}
inline ::int32_t ObjectIn::egoid() const {
  // @@protoc_insertion_point(field_get:carla.ObjectIn.egoId)
  return _internal_egoid();
}
inline void ObjectIn::set_egoid(::int32_t value) {
  _internal_set_egoid(value);
  // @@protoc_insertion_point(field_set:carla.ObjectIn.egoId)
}
inline ::int32_t ObjectIn::_internal_egoid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.egoid_;
}
inline void ObjectIn::_internal_set_egoid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.egoid_ = value;
}

// int32 fromId = 3;
inline void ObjectIn::clear_fromid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fromid_ = 0;
}
inline ::int32_t ObjectIn::fromid() const {
  // @@protoc_insertion_point(field_get:carla.ObjectIn.fromId)
  return _internal_fromid();
}
inline void ObjectIn::set_fromid(::int32_t value) {
  _internal_set_fromid(value);
  // @@protoc_insertion_point(field_set:carla.ObjectIn.fromId)
}
inline ::int32_t ObjectIn::_internal_fromid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fromid_;
}
inline void ObjectIn::_internal_set_fromid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fromid_ = value;
}

// -------------------------------------------------------------------

// Control

// int32 id = 1;
inline void Control::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Control::id() const {
  // @@protoc_insertion_point(field_get:carla.Control.id)
  return _internal_id();
}
inline void Control::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:carla.Control.id)
}
inline ::int32_t Control::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Control::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .carla.Vector waypoint = 2;
inline bool Control::has_waypoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.waypoint_ != nullptr);
  return value;
}
inline void Control::clear_waypoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.waypoint_ != nullptr) _impl_.waypoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::carla::Vector& Control::_internal_waypoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::carla::Vector* p = _impl_.waypoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::carla::Vector&>(::carla::_Vector_default_instance_);
}
inline const ::carla::Vector& Control::waypoint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:carla.Control.waypoint)
  return _internal_waypoint();
}
inline void Control::unsafe_arena_set_allocated_waypoint(::carla::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.waypoint_);
  }
  _impl_.waypoint_ = reinterpret_cast<::carla::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla.Control.waypoint)
}
inline ::carla::Vector* Control::release_waypoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* released = _impl_.waypoint_;
  _impl_.waypoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::carla::Vector* Control::unsafe_arena_release_waypoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:carla.Control.waypoint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::carla::Vector* temp = _impl_.waypoint_;
  _impl_.waypoint_ = nullptr;
  return temp;
}
inline ::carla::Vector* Control::_internal_mutable_waypoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::carla::Vector>(GetArena());
    _impl_.waypoint_ = reinterpret_cast<::carla::Vector*>(p);
  }
  return _impl_.waypoint_;
}
inline ::carla::Vector* Control::mutable_waypoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::carla::Vector* _msg = _internal_mutable_waypoint();
  // @@protoc_insertion_point(field_mutable:carla.Control.waypoint)
  return _msg;
}
inline void Control::set_allocated_waypoint(::carla::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::carla::Vector*>(_impl_.waypoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::carla::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.waypoint_ = reinterpret_cast<::carla::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:carla.Control.waypoint)
}

// double speed = 3;
inline void Control::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
}
inline double Control::speed() const {
  // @@protoc_insertion_point(field_get:carla.Control.speed)
  return _internal_speed();
}
inline void Control::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:carla.Control.speed)
}
inline double Control::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void Control::_internal_set_speed(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_ = value;
}

// double acceleration = 4;
inline void Control::clear_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_ = 0;
}
inline double Control::acceleration() const {
  // @@protoc_insertion_point(field_get:carla.Control.acceleration)
  return _internal_acceleration();
}
inline void Control::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:carla.Control.acceleration)
}
inline double Control::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_;
}
inline void Control::_internal_set_acceleration(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceleration_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace carla


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_carla_2eproto_2epb_2eh
